# 3주차 WIL


## 1. 사라지는 발판 (92345)
이번주에 가장 많은 시간을 쏟은 문제입니다. 새로운 개념을 공부하느라 참 고생했었네요.

### (처음에 생각한) 해결 방법

1. board 배열을 가지고, A와 B가 각각 돌아가면서 traverse 합니다. (정점에 방문하면 board가 0이 되니 방문 여부를 배열로 따로 기록할 필요는 없습니다.)
2. 누구의 차례던지 상관 없이, 움직일 수 없거나, 자신이 움직일 차례에 발판이 없어지면 그때의 움직인 수의 최소값을 갱신합니다.

근데 이 로직으로 한 한시간정도 직접 손으로 그려보니, 예시 테케는 모두 맞는데, 본 테케는 30점 정도밖에 안나오더군요.

문제의 조건 중에 **최적의 플레이를 한다**를 제대로 이해하지 못헀기 때문입니다.
이기는 사람의 입장에서는 최소한의 움직임으로 이겨야 최적의 플레이를 한 것이지만, 뒤집어 생각해보면 진 사람의 입장에서 볼 때, 최소한의 움직임으로 잡혀버린게 지지 않기 위해 최적의 움직임을 보여준 것 이라고 할 수 없죠. 오히려 최악의 움직임을 보여준 것 입니다.

여기서 **미니맥스 알고리즘**의 개념이 등장합니다.
간단하게 말해보자면, 미니맥스 알고리즘은 이기는 경우를 고려하는 것이 아닌, 질 때의 경우에 손해를 최소화 하는 방법을 선택하는 알고리즘 입니다.
그럼, 상황에 따라 내가 질 수도, 이길수도 있는건데 어떻게 선택을 해야 할까요?

완전 탐색을 통해 상대방과 할 수 있는 모든 게임을 다 해본 다음에 판단하는 것 입니다.
내가 모든 게임을 다 해서 내가 이기는 경우밖에 없었다? 그럼 모든 게임의 결과 중 내가 가장 작은 수로 움직여 이긴 경우를 선택하면 됩니다.
반대로 내가 한 번이라도 지는 경우가 있다? 최대한 오래 버틴 경우를 선택하면 되겠죠.

그래서 해결 방법을 아래와 같이 수정합니다.

### (두번째 생각한) 해결 방법

1. 현재 정점에서 시작하는 모든 게임의 결과를 탐색합니다.
2. 탐색 결과 내가 한번이라도 지는 경우가 있다면, 최대한 오래 버틴 경우를 선택하고,
3. 내가 전부 이긴다면, 가장 빠르게 이긴 경우를 선택합니다.
4. 이렇게 시작 정점에 대해서도 결과가 구해집니다.

해결에 엄청 큰 노력을 들였습니다... 결론적으로 구글링의 힘을 받아 해결했지만 미니맥스라는 알고리즘을 새로이 배우게 되었네요.

## 행렬 테두리 회전하기 (77485)
쉬운 문제였는데, 조건을 제대로 읽지 않아서 오래걸렸던 문제였습니다.

이 문제가 특히 오래걸렸던 이유가,,, 보통 좌표평면에 대응되는 그래프를 주면, x축은 horizontal, y축은 vertical이라고 생각하는게 보통의 상식인데,
이 문제는 이게 반대로 되어있습니다... 이걸 문제 해결 후반에 인지해서 아주 깊은 빡침과 함께 문제를 해결했습니다.

### (처음에 생각한) 해결 방법

1. 행렬의 테두리를 4개로 나눌 수 있습니다. 이하 상하좌우로 부르겠습니다.
2. 상 에 위치한 행렬 요소들은 1증가, 하 에 위치한 요소들은 1 감소, 좌는 columns 증가, 우는 columns 만큼 증가입니다.
3. 회전 전에 최소값을 배열에 추가하고 회전합니다.
4. 남은 회전에 대해 반복합니다.

실제 배열 요소를 변경하는 것 보다, 이렇게 값을 바꿔주는게 훨씬 빠를 것이라 생각했었는데,, 결론적으로 틀렸습니다.
이 로직은, 배열의 요소가 초기 상태처럼 정확히 1씩만 증가할 때 유효한 방법이었습니다. 회전이 일어나고 나서는 상대적인 값의 차이를 이용 할 수 없었던 것이죠.

결국 직접 배열의 값을 비교해서 교체해야 한다는 의미입니다.
최악의 경우에도, (400-2)*10000번 연산을 하기 때문에 시간제한에도 들어가지 않습니다.

### (두번째 생각한) 해결 방법

1. 처음 생각한 테두리 상하좌우를 슬라이싱 해서 가지고 있다가,
2. 시계방향으로 한칸 회전한 위치에 그대로 대입합니다.
3. 최소값을 배열에 추가합니다.
4. 남은 회전에 대해 반복합니다.



## 다단계 칫솔 판매 (77486)
레벨 3 치고 쉬웠습니다. 시간도 제일 적게 걸렸네요.

1. enroll, referral을 순회하며, 수익 분배 구조를 {child: parent}의 형태의 딕셔너리로 파싱합니다
2. seller, amount를 순회하면서, 수익 분배 구조 딕셔너리를 가장 루트 노드에 도달할 때 까지 탐색하 가며, 수익의 10%씩 제하면서 더해갑니다.
3. 모든 노드의 탐색이 끝나면 답이 나옵니다.

다만, enroll의 최대값이 10,000이고, seller의 최대값이 100,000이기 때문에, 차수가 1인 트리의 형태로 나온다면 시간 초과가 날 것이라 생각했습니다.

저의 경우 시간초과가 한번 발생 했었는데, 2번의 탐색 중지 조건에 남은 금액이 0일때를 추가하니 빠르게 통과할 수 있었습니다.
amount의 최대값이 100이기 때문에, 한 seller의 판매액의 최대값은 10,000원 입니다. 이는 5회 이상의 트리 탐색은 의미가 없다는 뜻입니다. (0원 이하가 되기 때문)
따라서 최악의 경우에도 500,000회의 연산만 필요하기 때문에 빠르게 해결이 가능했습니다.

