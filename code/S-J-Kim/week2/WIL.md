# 2주차 WIL
이번주는 저번주보다 훨씬 어려웠고 현타 가득한 일주일이었네요,,,, __하__

## 1. 양과 늑대 (92343)
이번주에 가장 많은 시간을 쏟아부은 문제입니다. 문제 자체가 어려워서라기 보다는, 될듯 말듯 계속 안되는 그 어딘가에서 헤메는데 시간을 엄청나게 사용했네요.

### (처음에 생각한) 해결 방법
갈수 없는 상태는 나중에라도 가야하지 않을까 라는 생각에서 시작된 아이디어 입니다.

1. 스택, 큐 하나씩 선언합니다. 스택은 traverse를 위한 것입니다.
2. 스택에 노드들을 담는데 노드가 담기는 시점의 `(노드 번호, 양의 수, 늑대의 수)`를 스택에 push합니다
3. 스택의 노드들을 순회하면서, 양이 늑대보다 많은 시점에, 그리고 양의 갯수가 최대값이 되는 시점의 양의 갯수와 늑대의 갯수를 기록해둡니다.
4. 늑대의 갯수가 더 많아 갈 수 없는 노드들은 큐에 push합니다.
5. 스택이 비게 되면 (모든 가능한 노드들의 탐색이 끝나면), 큐에 있는 노드를 스택으로 불러와 순회합니다.
6. 큐 까지 비게 되면 그때의 양의 갯수 최대값이 정답입니다.

근데 이 로직으로 한 한시간정도 직접 손으로 그려보니, 큰 문제가 있었습니다.

일종의 그리디 방식으로 항상 양의 갯수가 최대값이 되는 방법으로 순회를 진행하였는데, optimal substructure가 정답의 일부가 되지 않을 수 있다는 점을 간과한 것이지요... 예시 2에 의해 저의 이 이론이 박살나고, 새로운 방법을 찾아 결국 질문을 뒤지고,,, 아이디어를 얻습니다.

### (두번째 생각한) 해결 방법

1. `(노드 번호, 양의 숫자, 늑대의 숫자, 가능한 경로)`를 인자로 갖는 함수를 계속해서 반복합니다.
2. 한 노드에 도착해서 늑대의 숫자가 양보다 같거나 많아지면 해당 노드는 더이상 탐색하지 않고,
3. 2번의 경우가 아닌 경우에 `가능한 경로`에 지금 노드의 자식을 추가합니다.
4. 나는 탐색이 완료되었으니 `가능한 경로` 목록에서 제외하고 자식노드에 대해 탐색을 이어나갑니다.
5. 이 과정을 모든 노드에 대해서 반복해서 이어나갑니다.
6. 반복이 완료되면 그 때의 최대값이 정답입니다.

질문의 힘까지 뒤졌는데 답이 자꾸 안나옵니다... 재귀가 자꾸 이상한 상황에서 끝나버리는 문제가 있었는데, 대체 왜 일까를 곰곰히 생각해보았습니다.

두번째 해결방법의 핵심은, 이미 방문한 경로는 기억해 뒀다가, 나의 상태가 달라졌을 때 방문할 수 있다는 점 입니다. 초기에 방문할 수 없다 해도, 경로상에 기록 해 두었다가, 다른 노드를 먼저 다녀오고 나서 방문이 가능해지면 그 때 방문 할 수 있는것이죠. 다만 이걸 최적의 방법으로 찾아내지는 못하고, 완전 탐색을 통해 해당 경우가 가능해질 때 탐색하는 방식입니다.

다만, 가장 핵심은 현재 상태에 `가능한 경로`를 기억해 뒀다가 나중에 다시 와야하는데, `가능한 경로`를 자꾸 다음 재귀 호출에 그대로 넘겨줘 버려서 `가능한 경로`가 자꾸 오염되버렸던 것 입니다. 저번주에 아주 잘 써먹은 `copy.deepcopy()`를 다시 한번 이용해서 잘 해결했습니다.

## 파괴되지 않은 건물 (92344)
시작부터 미리 말씀드리지만, 저는 이 문제를 상대로 완벽하게 패배했다고 할 수 있습니다. 답을 보고나니 애초에 제가 풀 수 없었던 문제였었네요. 앞으로 더욱 공부 열심히 해야겠습니다.

아마 다들 처음엔 같은 방법을 생각하셨을 겁니다.
1. 스킬에 나온 범위만큼 for문을 돌려서 증감을 적용한다
2. 모든 스킬 리스트가 끝날때 까지 반복

근데,,, 정확성 테스트는 문제가 없는데 효율성 테스트가 문제였습니다. `board`의 크기는 최대 1백만이고, `skill`의 길이는 최대 25만이니 최악의 경우 2.5*10^11회의 연산이 들어가는데 1억회 연산에 1초라고 쳐도 이건 250초가 걸립니다. 

결국 핵심은 한 스킬이 일어날 때 마다 기록하기 보다는, 스킬을 기록했다가 한번에 적용할 수 있어야 한다는 뜻 입니다.

여기서 **누적합**이라는 개념을 처음 알게 되었습니다.
만약 길이가 5인 배열 `[5,5,5,5,5]` 에서 (1, 3)의 범위의 값을 1씩 줄이고 싶다면 어떻게 할 수 있을까요?
`[0, -1, 0, 0, 1]`의 누적합을 구하면 `[0,-1,-1,-1,0]`입니다. 이를 원 배열에 그대로 더해버리면 값을 얻을 수 있죠. 중요한 사실은 `[0, -1, 0, 0, 1]`에 그 다음번의 범위의 변경에 같은 방식을 계속해서 더해나간 다음 누적합을 구하는 것이 가능하다는 것 입니다. `O(1)`에 스킬 적용이 가능해지죠 (누적합을 구하는 단계는 논외)

그럼 이를 2차원 배열로 확장시키려면 어떻게 할까요? (r1, c1)에서 (r2, c2)까지 값을 1 줄이고 싶다면 
`arr[r1][c1] += 1``arr[r1+1][c2] -= 1``arr[r2][c1+1] -= 1``arr[r2][c2] += 1`를 하면 됩니다.

그런 다음 row 방향에 대해 누적합을 구하고, column 방향에 대해 누적합을 구하면 됩니다.

## 신고 결과 받기 (92334)
굉장히 간단했는데요, 그래서 리팩토링을 한번 했습니다.

1. 개별 신고 목록을 신고자, 피신고자로 나눕니다.
2. 개별 신고 목록을 순회하며 `{피신고자: [신고자 목록]}`의 형태로 딕셔너리를 채웁니다.
3. `신고자 목록`의 길이가 `k` 이상인 값들만 필터링하고, 각 신고자 목록에 유저 이름이 몇번 들어가있는지 셉니다 (메일을 받은 횟수)

