# 5주차 WIL


## 1. 카드 짝 맞추기 (72415)
그동안 스터디 진행하면서 제일 어려웠던,,, 절망과 공포를 안겨준 문제가 아니었나 싶었습니다.

처음에는, DFS를 이용한 완전탐색을 이용하면 되지 않을까 싶었는데,,, 택도 없더라구요.

근 이틀간을 머리를 싸매고 고통받은 다음에 결국 구글의 힘을 빌렸습니다.
결론부터 말하자면, 앞으로 이런 문제가 나온다면? 저는 그냥 틀리고 차라리 다른 문제 맞추는데 노력하겠습니다.

### 해결 방법
1. 한 카드 종류는 총 2개씩 있습니다. 편의상 Xa, Xb라 칭합니다.
2. 카드는 최대 6종류가 있습니다. 어떤 카드를 먼저 뒤집을지는 순열로 결정합니다.
3. 순열 순서중 한 카드 종류 X에 대해서 Xa -> Xb, Xb -> Xa 중 이동횟수가 더 적은 경우를 고릅니다
4. 모든 순열을 전부 탐색하고 최소값을 고릅니다

제 방식이 그리디 방식이라고 생각을 하는데, 이 문제는 그리디가 아닌것 같단 말이죠. 아직도 어떻게 풀리는지 의문이 있습니다. 조금 더 공부해봐야 하겠네요.
하여튼간에 이번주에 엄청난 절망을 안겨준 문제였습니다. 씁쓸...

## 외벽 점검 (60062)
원형을 어떻게 선형 자료구조에 표현해 내는지가 관건인 문제였던 것 같습니다.

weak = [a, b, c, d] 라고 하면, weak의 모든 원소에 n씩 더해줘서 계속 append 한다면, 선형 탐색으로도 원형 구조의 모든 경우의 수를 탐색할 수 있습니다.
weak = [a, b, c, d, n+a, n+b, n+c, n+d] 로 만들면 됩니다.

저는 모든 취약점을 시작점으로 하여 조사해보기 때문에, 그리디로 해결할 수 있다고 생각했습니다.
dist를 내림차순으로 정렬한 다음에 배치하면 되는 문제라 생각했었는데, 그렇지 않은 테스트 케이스들이 몇몇 있었습니다.

하지만 경우의 수가 많지 않은 점을 고려, dist의 순열을 구해서 해결해도 시간이 초과하지 않습니다.

또한, 한 친구가 점검할 수 있는 외벽의 갯수를 판단하는 방법에서 upper bound의 개념이 필요헀습니다.
항상 bisect는 이분탐색의 용도로만 사용했었는데, bisect_right가 upper bound를 찾는 함수였다는 것을 다시한번 상기하는 계기였네요.

i번째 친구가 j번째에 오는 외벽을 점검할 수 있는지 확인하고 싶다면, `bisect_right(weak, dist[i]) >= j` 인지 확인하면 됩니다

### 해결 방법
1. weak 배열을 선형 탐색이 가능하도록 보간합니다. (위에 참고)
2. weak 배열 시작점을 하나씩 증가시킨다는 의미는, 처음 시작하는 취약점을 다르게 한다는 의미입니다.
3. 각 순회 순서에 대해, dist의 순열을 계산해 친구들을 점검시켜 보고 최소값을 찾습니다.


## 방금그곡 (17683)
반음계를 한 문자로 치환할 수 있다면 쉽게 처리할 수 있었습니다. 풀어놓고 보니까 준환님과 같은 방법으로 처리했었네요... 이것은 데스티니?

### 해결 방법
1. 반음계 (C#, E# 등)은 한글자로 치환합니다. (저는 소문자로 바꿨습니다)
2. musicinfo를 순회하면서, 노래가 재생된 시간 만큼 노래의 길이를 늘리거나 자릅니다.
3. 이 늘리거나 줄인 노래에 m이 포함되는지 판단합니다.
4. 포함되고, 재생시간이 최대값이라면 갱신합니다.

근데 저는 이 문제를 풀면서 거의 아슬아슬하게 시간초과를 면했습니다. 거의 8500ms 내외의 실행시간이 나왔는데요.

범인은 copy.deepcopy()였습니다. 불필요한 copy를 줄이니 속도가 매우매우 빨라졌습니다 (8500ms -> 2ms). 해당 함수의 구현이 어떻게 되어있는지는 몰라도, 공간복잡도에만 영향을 미칠줄 알았으나 아주 매우 느린 함수였습니다. 최대한 지양하는게 좋을 것 같아요.
