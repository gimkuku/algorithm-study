# 1주차 WIL

## 1. k진수에서 소수 개수 구하기 (92335)
저는 첫주차부터 카카오 코테 문제를 주시길래,,, 아 이거 장난아니게 빡세게 가는구나 생각했었단 말이죠... 알고리즘은 제가 여기 계신 분들중에 제일 못할거 같은데...
근데 아주 다행스럽게 레벨 2 문제여서 크게 어렵지 않게 해결했습니다.

### 해결 방법
**소수**라고 말하니, $O(logn)$에 해결하는 방식과 에라토스테네스의 체가 먼저 떠오르더랍니다.
근데 명색이 카카오 코테인데, 에라토스테네스의 체를 사용해서 $O(1)$에 해결하도록 문제가 나오지 않을까 싶어서 에라토스테네스의 체를 구현(정확히는 복붙)했습니다.

그래서 어떤 방식으로 해결을 하였느냐,
1. 에라토스테네스의 체를 이용, 1000000 이하의 모든 소수를 걸러내고,
2. 입력받은 `n`을 `k-ary`로 변환합니다.
3. `k`진수로 변환한 `n`에 대해 정규표현식을 이용해 0이 1회 이상 반복되는 모든 패턴을 제거하고
4. 개별 제거된 숫자에 대해 소수 여부를 판별합니다.

### 문제는
호기롭게 채점을 돌리니까 런타임 에러가 발생해버리네요? *어라라*
1 ≤ `n` ≤ 1,000,000이라고 써놓아서 당연하게 1 ≤ `P` ≤ 1,000,000 라고 생각해버린거죠

그래서 해결방법을 다음과 같이 변경합니다.
1. 입력받은 `n`을 `k-ary`로 변환합니다.
2. `k`진수로 변환한 `n`에 대해 정규표현식을 이용해 0이 1회 이상 반복되는 모든 패턴을 제거하고
3. 개별 제거된 숫자에 대해 소수 여부를 판별합니다.

여기서 소수 판별은 $O(logn)$에 해결하는 전형적인 방식을 사용했습니다.

### Retrospect
진수 변환을 다들 어떻게 하셨는지 모르겠군요
`divmod(dividend, divisor)`라는 파이썬 내장 함수가 있습니다.
해당 함수는 `dividend`를 `divisor`로 나눈 결과에 대해 `(quotient, remainder)` 튜플을 리턴합니다
근데 굳이 필요는 없어보이네요.

## 2. 양궁대회 (92342)
처음엔 수학문제인가? 싶었는데, 완전탐색이었네요. 이번주에 가장 많은 시간과 노력을 들여서 해결한 문제입니다.
제가 제일 약한 부분이 재귀를 쓰는 유형(DFS, DP)인데, 이번 문제는 DFS + DP를 통해 해결했습니다. 제 실력에 대해 다시한번 겸손해지는 계기였구요...

### 해결방법
1. 10점 과녁부터 시작하여, 0점까지 어피치의 점수판을 보고, 각 점수를 라이언이 가져가느냐, 가져가지 못하느냐로 나누어 계산합니다.
2. 남은 화살이 없거나, 0점까지 모두 계산하였으면, 이제 계산된 라이언의 점수 리스트를 가지고 둘의 점수를 계산합니다.
3. 점수차가 가장 크고, 낮은 점수를 많이 맞춘 경우를 답으로 가져갑니다.
4. 1번의 과정을 이제 9번 과녁에서 다시 시작합니다.
5. 4번의 과정을 0번 과녁에서 시작할때 까지 반복합니다.

### 정말 짜증나던 부분
우선, DFS와 DP에 약한지라, 문제를 어떻게 풀어야 할지 자체에 대해서도 큰 고민을 했습니다. 어찌저찌 문제는 풀어나갔으나, 계속 8번과 18번 케이스에서 에러가 나더군요. 한 한시간정도 진득히 고민해봐도 답이 도저히 나오지 않아서 결국 질문의 힘을 빌렸습니다.

결국 문제는, *라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요*를 제대로 구현하지 못하였기 때문입니다.

저는 단순히 이런식으로 비교하려고 생각했습니다.
1. 현재 정답으로 저장된 리스트와, 비교할 리스트를 0점부터 비교합니다.
2. 비교할 리스트의 값이 정답 리스트보다 큰 인덱스가 있다면 비교할 리스트를 정답으로 바꿉니다.

지금 써보니까 말도 안되는데, 왜 그랬었을까요. 곰곰히 생각해보니 더 낮은 점수에서 정답 리스트가 값이 크고 다음 낮은 점수에서 작은 경우에도 답을 바꿔버리는 경우가 있었습니다. 그래서 아래의 과정을 통해 값을 비교합니다.
1. 두개의 리스트를 0점부터 비교합니다.
2. 현재 정답 리스트가 더 큰 값을 가지는 인덱스가 있으면 비교를 중단합니다.
3. 비교할 리스트의 값이 더 큰 인덱스가 생기면 비교할 리스트를 정답으로 바꿉니다.
4. 둘의 값이 같으면 넘어갑니다.

### Retrospect
정말 수학적 사고가 안되나 싶었음을 느낀 문제였습니다. 흑흑. 항상 이론상으로 DFS는 그래프의 정점을 탐색한다는 점은 알고 있었지만, 이를 완전탐색에 적용해서 문제를 해결해본게 거의 처음이라 앞으로 좀 더 잘 대비할 수 있을거 같군요.

## 3. 주차 요금 계산 (92341)
전형적인 구현 문제인데, 방법은 쉽게 떠오르는데 완성이 오래걸려서 짜증나는 유형입니다.

### 해결 방법
1. 입력받은 입출차 기록을 `[시각, 번호, 입출차여부]`로 분할해서 `{번호: [시각, 입출차여부]}`의 형태의 딕셔너리로 파싱합니다.
2. 파싱된 입출차 기록을 보고, 마지막 입출차 여부가 `IN`이면 23시 59분에 출차한 기록을 interpolate합니다.
3. 보간된 입출차 기록에 대해 `datetime`모듈을 이용해 총 주차시간을 분단위로 계산합니다.
4. 계산된 주차 시간을 단위시간, 단위금액에 맞춰 계산하고 정렬합니다.

### Retrospect
사실 어려운 문제가 아니라 딱히 특이사항도 없었네요.

다만, 딕셔너리에 값을 넣을때 초기에 key가 존재하지 않는 경우에 저는 `KeyError`가 발생하는것을 이용해 `try-except`로 처리했는데 여러분들은 어떤 방식으로 딕셔너리에 초기 값을 넣으시는지 궁금합니다. 파이썬에도 `undefined`가 있었으면 좋겠네요..