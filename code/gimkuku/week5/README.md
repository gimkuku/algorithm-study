## 카드 짝 맞추기
- 단도직입적으로 말하겠습니다. 못풀었어요 ^^*
- 내가 생각한 방식
    1. 카드의 max 값을 구한 뒤, 순열로 카드의 탐색 순서를 지정함
    2. 탐색 순서대로 dfs로 카드 탐색 
    3. 인덱스 구해서 최소값 구하기

- 틀린 이유
    1. 카드가 같은 숫자가 여러번 나올수도 있음
    2. 컨트롤이 있어서 인덱스 구하기 애매..

- 바뀐 풀이
    1. 보드를 한줄로 붙여서 string으로 만든 뒤,
    2. 큐로 구현하여 bfs(시작점부터 앞뒤양옆,컨트롤앞뒤양옆을 queue에 넣기)
    3. 없어진 점 => 0 으로 바꾸기
    4. 현재 하나가 까져있으면 : enter에 까진 점 포지션 넣기
    5. 하나도 안까져있으면 : enter = 미방문 포지션
    6. 모두 방문했으면 count 리턴 <- 가장 빨리 방문했을 때 리턴 = 가장 적은 count 수

### deque 란?
- 시작, 끝으로 추가 삭제 가능
- 큐, 스택으로 모두 사용
```
# import 해주어야 함
from collections import deque

deque.append(item): item을 데크의 시작에 삽입
deque.appendleft(item): item을 데크의 끝에 삽입
deque.pop(): 데크의 끝 엘리먼트를 가져오는 동시에 데크에서 삭제
deque.popleft(): 데크의 시작 엘리먼트를 가져오는 동시에 데크에서 삭제
```


## 외벽 점검
- 이것도 진짜 어려웠는데.. 이거 풀고 1번 풀 맘 싹 사라짐
- 내가 푼 방식
    1. 친구들이 출발할 순서를 순열로 미리 정함
    2. 원모양이므로 i+n씩해서 원래 weak배열에 붙여서 선으로 만듬
    3. 2로만든 배열에 1로 만든 친구들 순서대로 출발시킴
    4. 방문한 점은 visited
    5. visited 가 weak 과 수가 같아지면 멈춤
- 이때, 친구가 가다가 실패하면 다음 친구는 그냥 그다음 점에서 출발하는데, 이 처리를 잘못해줘서 해맸다
- 출발할때마다 시작 지점을 정해줘야 함
```
# 다음 친구는 다음 지점에서 출발
    start_point = dist_list[idx]
```

### permutation tip 
- itertool을 쓰면 결과물이 () 괄호 안에 나온다.
- 이걸 list로 나오게 하는 방법 : map을 사용해서 list로 해주면 된다. 
```
list(map(list, permutations(dist, len(dist))))
```
- 결과
    - before (1,2,3,4),(1,2,4,3), ... 
    - after  [[1,2,3,4],[1,2,4,3],...,]


## 방금그곡
- 이번주 힐링 문제^^*
- 내가 푼 방식
    1. 알파벳을 아스키코드(숫자)로 바꾼다
    2. #이 나오면 마지막 숫자에 7을 더한다(음계가 7개니깐)
    3. 시간을 계산한다
    4. 숫자로 바꾼 애들을 시간만큼 반복해서 긴 str으로 만든뒤, if i in str 으로 찾아줌
- 테케 8번만 안돼서 엄청 애먹었는데, 마지막에 #이 있을때 while문 시간만큼 반복에서 #이 적용이 안되는 것을 발견
- 이 경우 예외처리 해줬더니 정답이었다(실전에선 못찾았을 듯)
- 이런 문제만 나오면 좋겠다^^/